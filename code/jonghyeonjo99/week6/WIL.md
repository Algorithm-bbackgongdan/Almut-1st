# 11053 : 가장 긴 증가하는 부분 수열

## code
```python
n = int(input())
arr = list(map(int,input().split()))
dp = [0 for _ in range(n)]

for i in range(n):
  for j in range(i):
    if arr[i] > arr[j] and dp[i] < dp[j]:
      dp[i] = dp[j]
  dp[i] += 1

print(max(dp))
```
### 결과
성공
### 접근
전체 수열을 차례로 방문하면서, 현재 위치해 있는 숫자가 이전의 숫자보다 작은지 확인한다. 그리고 현재 위치의 dp에 저장되어있는 부분수열의 크기가 이전의 부분수열의 크기보다 작으면 이전의 부분수열 크기로 갱신해준 후, 현재 위치의 숫자까지 수열에 포함되기 때문에 수열 크기(dp[i])에 1을 더해준다.

이후 dp에 저장된 부분수열의 크기중 가장 큰 값을 출력한다.
## 문제 회고
점화식을 따라가면서 답을 구하는 비교적 쉬운 dp문제만 접해봐서
처음 문제를 봤을 때 어색했다. 문제 접근이 곧 떠올라 쉽게 풀 수 있었다.

# 1106 : 호텔
### code
```python
  C,N = map(int,input().split()) # 늘려야하는 고객수 C와 홍보할 수 있는 도시개수 N
  cost_list = [list(map(int,input().split())) for _ in range(N)] # 비용과 비용으로 얻을 수 있는 고객수
  dp = [1e7 for _ in range(C+100)] # dp 리스트 매우 큰값으로 초기화
  dp[0]=0 # 0명 모을 땐, 0원
 
  for cost, num_people in cost_list: # 각 비용, 비용으로 얻을 수 있는 고객수에 대해
    for i in range(num_people,C+100): # num_people 부터 C+100 까지 반복
        dp[i] = min(dp[i-num_people]+cost, dp[i]) # i명일 때, 최소비용 갱신
 
  print(min(dp[C:]))
```
### 결과
실패
### 접근
dp문제라고는 생각이 들지 않을 정도로 문제가 낯설고 어려웠다.
결국 구글링을 통해서 공부해보자 하였는데,
얻어야하는 고객명수 c명보다 더 많은 고객을 얻었을 때 최소비용이 나올 수 있는 상황을 고려한 출력형식을 처음 배웠다.

## 문제 회고
답을 확인하고도 다시 풀어보라하면 풀지 못할 것같다ㅋㅋㅋ

아래의 글은 이 문제를 이해하는데 도움이 많이 된 블로그 글 주소입니다.

https://bio-info.tistory.com/218

# 1513 : 경로찾기

### code
```python  
```
### 결과
실패
### 접근
dp문제가 아니라 그래프 순회관련 문제인줄알았다
구글링을 통해 배워보고자하였는데 dp배열 인덱스가 현재의 위치, 방문한 오락실 중 최대번호, 방문한 오락실의 개수를 가르키고 해당하는 값은 인덱스 조건을 만족하는 경로의 개수가 저장된다는 것을 알고 풀이를 따라갔는데 이해하기가 어려웠다.
## 문제회고
이 문제뿐만 아니라 이번주차에 dp를 공부하면서 머리를 몇번이나 쥐어뜯었는지 모르겠다ㅋㅋㅋㅋ
이번주 문제를 너무 못푼거같아 괴롭지만, 알멋 회원님들 풀이를 보고 한수 배우겠습니다ㅠㅠ


